/* NETWORK */

const STD_TAKEPORT = "take_port";
const STD_ETHPORTSINFO = "eth_ports_info";
const STD_SENDPCKG = "send_package";
const STD_SENDPCKGPORT = "send_package_port"
const STD_RESPPCKG = "response_package";

const PROTO_TCP = "TCP";
const PROTO_UDP = "UDP";

const DHCPDISCOVER = "DHCPDISCOVER";
const DHCPOFFER = "DHCPOFFER";

const DHCPSRVPORT = 67;
const DHCPCLIENTPORT = 68;

const _std = _process.std;

var _vm, 
	_fs, 
	_cidr,
	_conf,
	defEth,
	rmEvPort = null;

const eventRm = {
	rx:[]
}
const events = {
	rx:{}
}
const ports = {};

_initialize = async () => {
	_vm = await _import("libs/vm");
	_fs = await _import("libs/fs");
	_cidr = await _import("libs/cidr");
	_yaml = await _import("libs/yaml");

	try {
		_conf = _yaml.load(await _fs.readFile("/kernel/network_conf/network"));
	} catch (e) {
		_std.write("Error in network file [ /kernel/network_conf/network ]");
		_process.exit(); 
	};
	await convertPortNames();
	if (setDefaultEth()) {
		await start();
	}
}

_exiting = async () => {
	eventRm.rx.forEach(i=>_vm.unlistenEvent(i))
	rmEvPort();
}

const getHost = (url) => /^(?:\w+\:\/\/)?([^\/]+)([^\?]*)\??(.*)$/.exec(url)[1]
const getEth = (ip) => {
	for (let name in _conf) {
		if (_cidr.checkIp(ip,_conf[name].ip)) {
			return name;
		}
	};
	return defEth;
};

const convertPortNames = async () => {
	const intList = await _vm.getInterfaces();
	const ports = intList.filter(i=>i.type == "ethernet").map(i=>i.name);
	for (let name in _conf) {
		ports.forEach(i=>{
			if (i.indexOf(name) === 0) {
				_conf[i] = _conf[name];
				delete _conf[name];
			}
		})
	};
	return true;
};

const setDefaultEth = () => {
	let first = false;
	for (let name in _conf) {
		if (!first) {first = name;};
		const eth = _conf[name];
		if (eth?.default) {
			defEth = name;
			return true;
		}
	};
	if (!defEth && first) {
		defEth = first;
		return true;
	} else {
		return false;
	}
}

const start = async () => {
	for (let name in _conf) { // Reg RX Events
		events.rx[name] = (data) => onRX(name,data);
		eventRm.rx[name] = _vm.listenEvent(`interfaces/ethernet/${name}/rx`,events.rx[name]);
	};
	rmEvPort = _std.read(stdin);
	await DHCP();
	_std.write(`Listening ${Object.keys(events.rx).join(", ")}`);
}

const DHCP = async () => {
	for (let name in _conf) {
		if (_conf[name]?.dhcp) { // check dhcp on port
			_vm.sendCommand(`interfaces/ethernet/${name}/send`,{
				protocol:PROTO_UDP,
				address:"*:"+DHCPSRVPORT,
				data:{
					type:DHCPDISCOVER
				}
			});
		}
	};
}

const stdin = async ({
		type,
		port = 0,
		protocol=PROTO_TCP,
		receiver=()=>{},
		onSuccess,
		onError,
		address="*:*",
		data,
		ethPort
	}) => {
	switch (type) {
		case STD_TAKEPORT: 
			if (ports[port]) {
				onError && onError("Port unavailable");
			} else {
				ports[port] = {protocol,receiver};
				onSuccess && onSuccess(() => { delete ports[port]; });
			}
		break;
		case STD_ETHPORTSINFO: 
			onSuccess({..._conf});
		break;
		case STD_SENDPCKG:
			const eth = ethPort || getEth(getHost(address).split(":")[0]);
			if (eth) { // Если есть порт по которому стучаться
				switch (protocol) {
					case PROTO_UDP:
						_vm.sendCommand(`interfaces/ethernet/${eth}/send`,{protocol,address,data});
						return true;
					break;
				}
			} else {
				return false;
			};
		break;
		case STD_SENDPCKGPORT:
			if (ethPort) { // Если есть порт по которому стучаться
				switch (protocol) {
					case PROTO_UDP:
						_os.console.log("SENDING",`interfaces/ethernet/${ethPort}/send`,{protocol,address,data});
						_vm.sendCommand(`interfaces/ethernet/${ethPort}/send`,{protocol,address,data});
						return true;
					break;
				}
			} else {
				return false;
			};
		break;
	}
}

const onRX = (eth,{address,data}) => {
	const port = +getHost(address).split(":")[1];
	if (port && data) {
		switch (port) {
			case DHCPCLIENTPORT: // DHCP
				_conf[eth] = {
					..._conf[eth],
					ip:`${data.YIADDR}/${data.OPTIONS.MASK}`,
					gateway:data.SIADDR,
					dns:data?.OPTIONS?.DNS || ""
				}
				_std.write(_conf[eth])
			break;
			default: // ANOTHER
				if (ports?.[port]) {
					ports[port].receiver(data,{..._conf[eth],name:eth});
				}
			break;
		}	
	};
}